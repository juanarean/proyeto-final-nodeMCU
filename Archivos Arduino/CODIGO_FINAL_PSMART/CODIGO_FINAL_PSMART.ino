
// CODIGO FINAL PSMART PROYECTO FINAL UTN FRBA AÃ‘O 2019

//DECLARACION DE INCLUDE
#include <PsmartWiFi.h>//PsmartWiFi.h   WiFiManager.h
#include <PubSubClient.h>
#include "INDEX.h" // EN ESTE INDEX.H SE ENCUNETRA LA PAGINA WEB EN HTML
#include<EEPROM.h>
#include <ESP8266WiFi.h>          
#include <Ticker.h>
#include <DNSServer.h>
#include <ESP8266WebServer.h>

// DECLARACION DE VARIABLES PARA FUNCION DE LECTURA DE TIMBRES
int Pctrl     = D2;
int DataSerIn = D4;
int Clk        = D1;
word switchVar1 = 72;


//ARRAY DE CERTIFICADOS DE AWS, ESTOS ARRAY SE GENERARON CON LAS CLAVES QUE NOS PROVEE EL SERVICIO IOT DE AMAZON
unsigned char private_der[] = {
0x30, 0x82, 0x04, 0xA3, 0x02, 0x01, 0x00, 0x02, 0x82, 0x01, 0x01, 0x00, 0xB2, 0x62, 0x77, 0x0C, 
0xFD, 0x28, 0x58, 0xD3, 0x39, 0xBF, 0x2B, 0x4E, 0x59, 0xF4, 0x08, 0x60, 0xC7, 0xB2, 0xE8, 0x18, 
0x5F, 0xCF, 0x40, 0x94, 0x4E, 0x8C, 0x53, 0xE7, 0xC5, 0x68, 0xF0, 0xC5, 0xA7, 0x3E, 0xD9, 0x75, 
0xF5, 0x66, 0xE2, 0xAF, 0xEA, 0x61, 0xCC, 0x47, 0x3C, 0xB8, 0x42, 0x0B, 0x6D, 0x8A, 0x96, 0x43, 
0x8A, 0x2D, 0xEA, 0x80, 0x98, 0x6E, 0x45, 0x20, 0xC1, 0xB8, 0x65, 0xA2, 0x1E, 0x20, 0x00, 0x94, 
0xC5, 0x30, 0xFE, 0xEC, 0x72, 0x9C, 0xBC, 0x61, 0x67, 0xCA, 0xB6, 0x6A, 0xE6, 0xF3, 0x00, 0xC6, 
0x37, 0x42, 0x63, 0xE0, 0x75, 0x72, 0xFE, 0xEC, 0xB1, 0x59, 0x6A, 0x2A, 0x04, 0x15, 0x76, 0x42, 
0x96, 0xAC, 0xE6, 0xD1, 0xB9, 0xDE, 0xBF, 0xC5, 0x57, 0x48, 0x6A, 0xB2, 0x18, 0x8D, 0x7F, 0x0D, 
0x60, 0xF6, 0xEB, 0x17, 0xD8, 0x7A, 0x4B, 0x0D, 0x6A, 0x4A, 0x8A, 0xB0, 0x7D, 0x4E, 0x4E, 0xC8, 
0x0C, 0x6E, 0xF2, 0xD0, 0xBF, 0x96, 0x8C, 0x13, 0xA9, 0xA2, 0xD2, 0x14, 0xE6, 0x15, 0x9B, 0xBE, 
0x08, 0xFE, 0x67, 0x45, 0xFD, 0xF6, 0x01, 0xDD, 0xBC, 0x88, 0xCF, 0x4B, 0x94, 0xF4, 0x93, 0x35, 
0x59, 0x08, 0xDA, 0x88, 0xC6, 0x5C, 0x4A, 0xF6, 0x3F, 0x9D, 0x72, 0x6D, 0x11, 0x83, 0x6A, 0xF9, 
0xB2, 0xAC, 0xB3, 0xE0, 0x91, 0x19, 0x1F, 0x7F, 0x6E, 0x36, 0x43, 0x92, 0x20, 0x55, 0x9B, 0xE9, 
0x6B, 0xE3, 0x3C, 0x5F, 0x3A, 0x29, 0x9F, 0x54, 0x42, 0xE5, 0x4F, 0xCA, 0x28, 0xCE, 0x44, 0x94, 
0x3E, 0x23, 0x0C, 0xF4, 0x54, 0xEB, 0xB0, 0xD0, 0x4E, 0xA4, 0x96, 0x57, 0x1B, 0x00, 0x5E, 0x2D, 
0xE1, 0xA3, 0x7C, 0x50, 0x79, 0xDB, 0x56, 0x7E, 0x15, 0x3E, 0x07, 0x14, 0x7C, 0xB5, 0x9C, 0xD7, 
0xB9, 0xE4, 0xC6, 0xCB, 0xC0, 0x95, 0x37, 0x2D, 0x8D, 0xAE, 0x44, 0x87, 0x02, 0x03, 0x01, 0x00, 
0x01, 0x02, 0x82, 0x01, 0x00, 0x5F, 0xF1, 0xA7, 0xD8, 0x9B, 0x9D, 0x04, 0xD1, 0x6F, 0x20, 0xCC, 
0x39, 0x13, 0x16, 0xB7, 0x1E, 0xDE, 0xA9, 0xF2, 0x3D, 0x91, 0xE2, 0x95, 0xF8, 0x6E, 0x9A, 0xF9, 
0x52, 0x12, 0x92, 0x93, 0xD5, 0xAB, 0x53, 0x99, 0x80, 0xE1, 0x61, 0xDA, 0x11, 0x05, 0xFE, 0x5D, 
0xF1, 0xFE, 0xCD, 0x97, 0xF0, 0x2F, 0x95, 0xB7, 0xA6, 0x51, 0xFE, 0xCA, 0x3F, 0x2A, 0x3D, 0x3C, 
0xFF, 0x16, 0x52, 0x88, 0x8F, 0x7E, 0xA6, 0x75, 0xC9, 0x8E, 0x9A, 0x00, 0xB2, 0xCA, 0x1E, 0x55, 
0x10, 0x0A, 0xD4, 0x33, 0xF3, 0x21, 0x8E, 0x97, 0xDF, 0x04, 0xBF, 0xB7, 0x9A, 0x75, 0x71, 0x49, 
0x7D, 0xA3, 0x11, 0xD5, 0x91, 0x0D, 0xAB, 0x41, 0x75, 0x25, 0x37, 0x8F, 0xDA, 0x43, 0x9F, 0x74, 
0x03, 0xBF, 0x23, 0x5B, 0x07, 0xB9, 0x3E, 0xF9, 0x94, 0x07, 0x90, 0x26, 0xF8, 0x27, 0x5D, 0xF7, 
0x5A, 0x1A, 0xCE, 0x46, 0xF3, 0x2A, 0x28, 0xF2, 0x89, 0x6E, 0xAD, 0xE4, 0xF4, 0xB1, 0xD1, 0x23, 
0x13, 0x2C, 0x19, 0xBC, 0x82, 0xCF, 0x57, 0x3E, 0x06, 0x9F, 0x05, 0xD9, 0xB6, 0x70, 0xA3, 0x71, 
0xA0, 0xD0, 0x94, 0xA1, 0xF9, 0xF0, 0x0A, 0xF9, 0xE0, 0x26, 0xA3, 0x79, 0xE6, 0x5D, 0x38, 0xAE, 
0xE4, 0x6B, 0x07, 0xC3, 0xF7, 0xC3, 0x1F, 0x74, 0x6D, 0xFC, 0xA5, 0xDF, 0xF4, 0xBE, 0xF5, 0x4C, 
0x9B, 0xBC, 0x0A, 0xBD, 0x6D, 0xD2, 0x51, 0xEC, 0x4F, 0x81, 0x21, 0xBD, 0xF1, 0xE6, 0x6E, 0xCC, 
0x3B, 0x95, 0x96, 0x70, 0xA5, 0x90, 0xDC, 0x4F, 0xB9, 0xE1, 0x25, 0xD0, 0x3F, 0x3D, 0x8C, 0x2F, 
0x78, 0xD9, 0xD7, 0xE0, 0x42, 0x86, 0xD5, 0x2D, 0xF4, 0x02, 0xB6, 0x9B, 0x97, 0xE4, 0x0F, 0x2B, 
0x05, 0x3C, 0xD5, 0x30, 0x53, 0xD5, 0xA7, 0xBE, 0xA8, 0x68, 0xE4, 0x5C, 0xAB, 0xD2, 0xD6, 0xA5, 
0x5A, 0xD6, 0x23, 0x72, 0x09, 0x02, 0x81, 0x81, 0x00, 0xDC, 0x01, 0xAC, 0xCC, 0x66, 0xF6, 0x3F, 
0xC3, 0xDD, 0x13, 0x43, 0xE9, 0xCB, 0x98, 0xCA, 0xE9, 0x34, 0x7D, 0x2A, 0xE9, 0x75, 0xAC, 0x59, 
0x8B, 0x11, 0x8F, 0x41, 0x23, 0x9A, 0x07, 0xEF, 0x06, 0x0C, 0xA6, 0x51, 0xAA, 0x11, 0x0A, 0x90, 
0xA8, 0xAA, 0xAC, 0x0A, 0xF9, 0xE6, 0x0F, 0xAE, 0x3F, 0xC9, 0xB1, 0x24, 0xD9, 0x01, 0x0C, 0x86, 
0x77, 0x3B, 0xDF, 0x9F, 0xA2, 0x0D, 0xA1, 0xE1, 0xD3, 0x9D, 0x11, 0x13, 0x92, 0xE0, 0x16, 0x3C, 
0x6E, 0x08, 0x1D, 0x7E, 0xD9, 0x67, 0xBB, 0xFB, 0x92, 0x55, 0x18, 0xC0, 0xF5, 0x6A, 0xD6, 0x28, 
0x53, 0xC0, 0xAD, 0xAE, 0xFD, 0x86, 0xDE, 0xED, 0x5C, 0xE2, 0x33, 0x60, 0xE7, 0xC1, 0x7C, 0x23, 
0xBA, 0xCB, 0x73, 0xF3, 0x7D, 0xF3, 0x70, 0x39, 0x27, 0x06, 0x9C, 0xE7, 0xD2, 0xA7, 0x4A, 0xE3, 
0x6E, 0x2E, 0xCD, 0xDA, 0x56, 0x83, 0x76, 0x73, 0x75, 0x02, 0x81, 0x81, 0x00, 0xCF, 0x91, 0x94, 
0x37, 0xB3, 0x0A, 0xFE, 0x33, 0x1A, 0x34, 0x2B, 0xC5, 0x8F, 0xE3, 0x05, 0xF7, 0xE7, 0xB3, 0x9B, 
0x87, 0x3E, 0x25, 0xFC, 0x69, 0xFA, 0xA1, 0x33, 0x50, 0x95, 0xEC, 0xC9, 0x89, 0x14, 0xF7, 0xFB, 
0xE6, 0xE3, 0x5D, 0x7D, 0x85, 0x63, 0xD2, 0x08, 0xE9, 0x9E, 0xBE, 0x4F, 0x46, 0x21, 0xF0, 0x20, 
0x65, 0x2C, 0x29, 0x5D, 0x24, 0xE5, 0xDB, 0xFB, 0x5D, 0x85, 0x7C, 0x1B, 0x52, 0x5F, 0xCC, 0x87, 
0x1B, 0x8A, 0x97, 0xE8, 0xD3, 0xEE, 0x81, 0xD9, 0x5C, 0x90, 0xA5, 0x95, 0x59, 0x64, 0x20, 0x88, 
0x24, 0xC5, 0x50, 0x96, 0x3D, 0xCF, 0x18, 0x6A, 0x69, 0x7C, 0x11, 0x8D, 0xBD, 0x5C, 0x47, 0xDF, 
0xD8, 0x2C, 0x07, 0xE5, 0x8C, 0x68, 0xD0, 0x22, 0x86, 0xFE, 0x1E, 0x9D, 0x48, 0x4B, 0x84, 0xD2, 
0xCB, 0xA0, 0xED, 0xA4, 0xD1, 0x89, 0x04, 0x42, 0x1F, 0xE5, 0x18, 0xC4, 0x8B, 0x02, 0x81, 0x81, 
0x00, 0xCE, 0xBF, 0xF4, 0x37, 0x92, 0x7A, 0xCF, 0xA9, 0xAC, 0xD4, 0x31, 0xFA, 0x40, 0x0E, 0xB2, 
0x81, 0x3D, 0x86, 0x73, 0x11, 0x3A, 0x38, 0x61, 0x5D, 0xC3, 0x7E, 0xB0, 0x64, 0x58, 0x98, 0x24, 
0x13, 0xB7, 0x47, 0x85, 0x6F, 0x20, 0xDC, 0xA0, 0xDD, 0x20, 0xA6, 0xD5, 0x19, 0xCB, 0x0D, 0xE9, 
0x5E, 0xA0, 0x98, 0x0C, 0x5C, 0xB2, 0x13, 0xA7, 0x39, 0xDD, 0xD6, 0x65, 0x19, 0xD1, 0x5D, 0xD3, 
0xEF, 0x1D, 0xA7, 0xB2, 0x91, 0x50, 0x6D, 0x15, 0x15, 0x02, 0x23, 0x55, 0xD5, 0xD1, 0x1A, 0x63, 
0x6C, 0x3C, 0xF4, 0x2A, 0x41, 0x77, 0xC9, 0x11, 0xD4, 0xC3, 0x39, 0x75, 0x3D, 0x63, 0xC5, 0x93, 
0xA2, 0xBA, 0x20, 0x36, 0x6D, 0x14, 0xF3, 0x28, 0x50, 0x9E, 0x69, 0xB4, 0xE5, 0x24, 0x24, 0xCE, 
0x50, 0xD2, 0x72, 0x19, 0x99, 0x69, 0x05, 0x83, 0x7D, 0x44, 0x16, 0xC7, 0x9C, 0x8D, 0xA6, 0x7F, 
0x11, 0x02, 0x81, 0x80, 0x3B, 0xD8, 0x1E, 0x22, 0x9C, 0xF5, 0x4B, 0x6A, 0xD2, 0x60, 0x3E, 0x4A, 
0x7C, 0x7C, 0x98, 0xC8, 0xEB, 0xBD, 0xA5, 0xD6, 0xAD, 0x3D, 0x68, 0x73, 0xE9, 0xB5, 0xB6, 0x44, 
0xC2, 0xA4, 0xFD, 0x4A, 0x0F, 0x88, 0x9B, 0xD0, 0xEA, 0xB6, 0x96, 0xAC, 0xF1, 0xA5, 0xA9, 0xBA, 
0x29, 0x71, 0x77, 0x0B, 0xA2, 0x57, 0x48, 0x0F, 0xC3, 0x56, 0xBD, 0xAB, 0x18, 0xB6, 0x7E, 0xD7, 
0x6C, 0xD7, 0xE6, 0x4C, 0xAE, 0xA0, 0x1A, 0x47, 0xFF, 0x82, 0x62, 0xB7, 0x4F, 0xA9, 0x92, 0x50, 
0x94, 0xC7, 0x98, 0xB2, 0xA8, 0x22, 0x94, 0xFD, 0xFD, 0x01, 0x89, 0xFF, 0x92, 0x08, 0xD9, 0x0D, 
0x46, 0x9F, 0x0C, 0xFD, 0x8E, 0x70, 0x8E, 0x82, 0x15, 0xD7, 0xC4, 0xFF, 0xE1, 0x6C, 0x38, 0xB8, 
0x30, 0xE6, 0x04, 0xB4, 0xC6, 0x49, 0x2A, 0x39, 0x59, 0x51, 0x8A, 0xD6, 0x7A, 0xA9, 0x86, 0xA3, 
0x09, 0x7B, 0x45, 0x97, 0x02, 0x81, 0x80, 0x05, 0x09, 0x88, 0x6C, 0xF2, 0xBF, 0xB5, 0x5E, 0x9B, 
0x86, 0x3B, 0xDE, 0x3D, 0x41, 0x05, 0x20, 0x7B, 0x76, 0x3D, 0xE5, 0xD4, 0x29, 0x65, 0xB1, 0xE7, 
0xD3, 0xF9, 0x34, 0x4A, 0x57, 0x00, 0xBA, 0x79, 0x75, 0xA7, 0xCF, 0xA2, 0x29, 0x7F, 0xBC, 0x6F, 
0xEB, 0xDA, 0x0B, 0xA3, 0xB0, 0x18, 0x29, 0x7A, 0xFA, 0xF0, 0x75, 0xF2, 0xF5, 0xC5, 0xD6, 0x92, 
0xF8, 0xA2, 0xD9, 0xAA, 0x68, 0xC8, 0x03, 0xAD, 0xA3, 0xB9, 0x5E, 0x43, 0x76, 0x3C, 0xE7, 0xF5, 
0x9C, 0x76, 0xBD, 0x5D, 0xFD, 0x9D, 0xBD, 0xF1, 0xC7, 0xAA, 0x54, 0x19, 0x2A, 0xB3, 0x24, 0x65, 
0x8E, 0xFB, 0x83, 0x60, 0x7C, 0xDD, 0xD9, 0xF5, 0xA1, 0xAA, 0x26, 0x9C, 0x32, 0x0F, 0xA0, 0xA1, 
0x21, 0x5E, 0x47, 0x0F, 0x5C, 0x6E, 0xC6, 0xA5, 0xC2, 0x6D, 0x3A, 0x85, 0x06, 0x92, 0x95, 0x66, 
0xFE, 0x49, 0x1A, 0x14, 0x13, 0x00, 0x58, 


};
unsigned int private_der_len = 1191;

//ARRAY DE CERTIFICADOS DE AWS
unsigned char cert_der[] = {
0x30, 0x82, 0x03, 0x5A, 0x30, 0x82, 0x02, 0x42, 0xA0, 0x03, 0x02, 0x01, 0x02, 0x02, 0x15, 0x00, 
0xED, 0x02, 0xAA, 0xCC, 0xDA, 0xD0, 0x4D, 0xB0, 0x9E, 0x4D, 0x63, 0xBE, 0xE0, 0x42, 0xB9, 0x94, 
0xE9, 0xB8, 0xCE, 0x82, 0x30, 0x0D, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 
0x0B, 0x05, 0x00, 0x30, 0x4D, 0x31, 0x4B, 0x30, 0x49, 0x06, 0x03, 0x55, 0x04, 0x0B, 0x0C, 0x42, 
0x41, 0x6D, 0x61, 0x7A, 0x6F, 0x6E, 0x20, 0x57, 0x65, 0x62, 0x20, 0x53, 0x65, 0x72, 0x76, 0x69, 
0x63, 0x65, 0x73, 0x20, 0x4F, 0x3D, 0x41, 0x6D, 0x61, 0x7A, 0x6F, 0x6E, 0x2E, 0x63, 0x6F, 0x6D, 
0x20, 0x49, 0x6E, 0x63, 0x2E, 0x20, 0x4C, 0x3D, 0x53, 0x65, 0x61, 0x74, 0x74, 0x6C, 0x65, 0x20, 
0x53, 0x54, 0x3D, 0x57, 0x61, 0x73, 0x68, 0x69, 0x6E, 0x67, 0x74, 0x6F, 0x6E, 0x20, 0x43, 0x3D, 
0x55, 0x53, 0x30, 0x1E, 0x17, 0x0D, 0x31, 0x38, 0x30, 0x39, 0x32, 0x31, 0x32, 0x31, 0x35, 0x37, 
0x31, 0x37, 0x5A, 0x17, 0x0D, 0x34, 0x39, 0x31, 0x32, 0x33, 0x31, 0x32, 0x33, 0x35, 0x39, 0x35, 
0x39, 0x5A, 0x30, 0x1E, 0x31, 0x1C, 0x30, 0x1A, 0x06, 0x03, 0x55, 0x04, 0x03, 0x0C, 0x13, 0x41, 
0x57, 0x53, 0x20, 0x49, 0x6F, 0x54, 0x20, 0x43, 0x65, 0x72, 0x74, 0x69, 0x66, 0x69, 0x63, 0x61, 
0x74, 0x65, 0x30, 0x82, 0x01, 0x22, 0x30, 0x0D, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 
0x01, 0x01, 0x01, 0x05, 0x00, 0x03, 0x82, 0x01, 0x0F, 0x00, 0x30, 0x82, 0x01, 0x0A, 0x02, 0x82, 
0x01, 0x01, 0x00, 0xB2, 0x62, 0x77, 0x0C, 0xFD, 0x28, 0x58, 0xD3, 0x39, 0xBF, 0x2B, 0x4E, 0x59, 
0xF4, 0x08, 0x60, 0xC7, 0xB2, 0xE8, 0x18, 0x5F, 0xCF, 0x40, 0x94, 0x4E, 0x8C, 0x53, 0xE7, 0xC5, 
0x68, 0xF0, 0xC5, 0xA7, 0x3E, 0xD9, 0x75, 0xF5, 0x66, 0xE2, 0xAF, 0xEA, 0x61, 0xCC, 0x47, 0x3C, 
0xB8, 0x42, 0x0B, 0x6D, 0x8A, 0x96, 0x43, 0x8A, 0x2D, 0xEA, 0x80, 0x98, 0x6E, 0x45, 0x20, 0xC1, 
0xB8, 0x65, 0xA2, 0x1E, 0x20, 0x00, 0x94, 0xC5, 0x30, 0xFE, 0xEC, 0x72, 0x9C, 0xBC, 0x61, 0x67, 
0xCA, 0xB6, 0x6A, 0xE6, 0xF3, 0x00, 0xC6, 0x37, 0x42, 0x63, 0xE0, 0x75, 0x72, 0xFE, 0xEC, 0xB1, 
0x59, 0x6A, 0x2A, 0x04, 0x15, 0x76, 0x42, 0x96, 0xAC, 0xE6, 0xD1, 0xB9, 0xDE, 0xBF, 0xC5, 0x57, 
0x48, 0x6A, 0xB2, 0x18, 0x8D, 0x7F, 0x0D, 0x60, 0xF6, 0xEB, 0x17, 0xD8, 0x7A, 0x4B, 0x0D, 0x6A, 
0x4A, 0x8A, 0xB0, 0x7D, 0x4E, 0x4E, 0xC8, 0x0C, 0x6E, 0xF2, 0xD0, 0xBF, 0x96, 0x8C, 0x13, 0xA9, 
0xA2, 0xD2, 0x14, 0xE6, 0x15, 0x9B, 0xBE, 0x08, 0xFE, 0x67, 0x45, 0xFD, 0xF6, 0x01, 0xDD, 0xBC, 
0x88, 0xCF, 0x4B, 0x94, 0xF4, 0x93, 0x35, 0x59, 0x08, 0xDA, 0x88, 0xC6, 0x5C, 0x4A, 0xF6, 0x3F, 
0x9D, 0x72, 0x6D, 0x11, 0x83, 0x6A, 0xF9, 0xB2, 0xAC, 0xB3, 0xE0, 0x91, 0x19, 0x1F, 0x7F, 0x6E, 
0x36, 0x43, 0x92, 0x20, 0x55, 0x9B, 0xE9, 0x6B, 0xE3, 0x3C, 0x5F, 0x3A, 0x29, 0x9F, 0x54, 0x42, 
0xE5, 0x4F, 0xCA, 0x28, 0xCE, 0x44, 0x94, 0x3E, 0x23, 0x0C, 0xF4, 0x54, 0xEB, 0xB0, 0xD0, 0x4E, 
0xA4, 0x96, 0x57, 0x1B, 0x00, 0x5E, 0x2D, 0xE1, 0xA3, 0x7C, 0x50, 0x79, 0xDB, 0x56, 0x7E, 0x15, 
0x3E, 0x07, 0x14, 0x7C, 0xB5, 0x9C, 0xD7, 0xB9, 0xE4, 0xC6, 0xCB, 0xC0, 0x95, 0x37, 0x2D, 0x8D, 
0xAE, 0x44, 0x87, 0x02, 0x03, 0x01, 0x00, 0x01, 0xA3, 0x60, 0x30, 0x5E, 0x30, 0x1F, 0x06, 0x03, 
0x55, 0x1D, 0x23, 0x04, 0x18, 0x30, 0x16, 0x80, 0x14, 0xA8, 0x84, 0x09, 0xFD, 0xDD, 0xFE, 0x5F, 
0x05, 0x16, 0x28, 0x46, 0x1F, 0x70, 0xFA, 0xAC, 0x6F, 0x46, 0x96, 0x2C, 0x0A, 0x30, 0x1D, 0x06, 
0x03, 0x55, 0x1D, 0x0E, 0x04, 0x16, 0x04, 0x14, 0x35, 0x15, 0x4B, 0xA4, 0x40, 0x15, 0xEA, 0x97, 
0x48, 0x9F, 0xFF, 0xA2, 0x7D, 0x1E, 0x7E, 0x88, 0x71, 0xD9, 0x9B, 0x27, 0x30, 0x0C, 0x06, 0x03, 
0x55, 0x1D, 0x13, 0x01, 0x01, 0xFF, 0x04, 0x02, 0x30, 0x00, 0x30, 0x0E, 0x06, 0x03, 0x55, 0x1D, 
0x0F, 0x01, 0x01, 0xFF, 0x04, 0x04, 0x03, 0x02, 0x07, 0x80, 0x30, 0x0D, 0x06, 0x09, 0x2A, 0x86, 
0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x0B, 0x05, 0x00, 0x03, 0x82, 0x01, 0x01, 0x00, 0x51, 0x7F, 
0x53, 0x4C, 0x81, 0xAA, 0x00, 0xEE, 0x18, 0xD2, 0x9D, 0xE6, 0x6A, 0xAB, 0xF5, 0x7E, 0xED, 0x3D, 
0xC7, 0xF6, 0x4E, 0x78, 0x02, 0xA9, 0x6B, 0xFC, 0x0C, 0xED, 0xF2, 0x3A, 0x6A, 0xC9, 0x28, 0xFC, 
0xC4, 0x21, 0x9C, 0x80, 0x32, 0xB4, 0x93, 0x11, 0x60, 0x71, 0x4C, 0x3E, 0xA3, 0x31, 0x23, 0xC4, 
0x18, 0x68, 0xB9, 0x06, 0x4C, 0x30, 0x03, 0x22, 0xEA, 0x0E, 0xD0, 0xD4, 0x8C, 0x2C, 0x5A, 0x3D, 
0x7F, 0x66, 0xD9, 0x8A, 0x18, 0xE8, 0xDE, 0xD5, 0x61, 0x54, 0xE8, 0xC5, 0x6A, 0xC3, 0xD5, 0x47, 
0xC8, 0xFE, 0xB7, 0xEF, 0x60, 0xE0, 0xD2, 0x19, 0xE8, 0x98, 0x3A, 0x1D, 0xD9, 0xCE, 0x98, 0xC6, 
0x28, 0x51, 0xBC, 0xB6, 0xB0, 0xE0, 0xDD, 0x75, 0x7C, 0xBA, 0x2D, 0x4F, 0x9E, 0x96, 0x46, 0xF6, 
0xD9, 0x7C, 0xEB, 0xD4, 0x38, 0x9D, 0xA5, 0x63, 0xFE, 0xE3, 0xB3, 0xE6, 0x00, 0x5C, 0x3A, 0x91, 
0x75, 0xB7, 0xF4, 0x41, 0xD2, 0xF1, 0x34, 0x44, 0x8D, 0xCD, 0xF6, 0xEE, 0x91, 0xA0, 0x01, 0xC1, 
0xE9, 0xD0, 0x50, 0x1E, 0xDE, 0x85, 0x3F, 0x5D, 0x25, 0x90, 0x1C, 0x73, 0xAC, 0xE9, 0x5F, 0xC8, 
0xE4, 0x1D, 0xA3, 0xC8, 0x0D, 0xDA, 0xB1, 0x5F, 0x30, 0x7A, 0xA8, 0x14, 0x94, 0xF6, 0xCD, 0x40, 
0xE9, 0x21, 0xEF, 0x0D, 0x38, 0xF6, 0x19, 0x1E, 0x32, 0x5D, 0xAA, 0x6C, 0x41, 0xBF, 0x71, 0x0D, 
0x20, 0x8E, 0x11, 0xD0, 0x69, 0xE5, 0x0A, 0x5E, 0x2F, 0x74, 0x77, 0xDF, 0x3F, 0x47, 0xB2, 0xA3, 
0xB3, 0x50, 0x8A, 0x7C, 0x3E, 0x18, 0xC3, 0xB7, 0xB4, 0x9A, 0xC4, 0xF1, 0x3F, 0x72, 0xC7, 0x07, 
0x73, 0xDC, 0xCF, 0xD1, 0xE4, 0x5F, 0x10, 0x04, 0xB0, 0xE6, 0x2D, 0x6E, 0xA8, 0x04, 0x73, 0xC2, 
0x0C, 0x27, 0xD8, 0x13, 0xF1, 0xEA, 0x55, 0x27, 0xE6, 0x2E, 0x43, 0xEA, 0x3A, 0xDF, 


};
unsigned int cert_der_len = 862;



//DECLARACION DE VARIABLES DE PAGINAS WEB EN MODULO
String s = MAIN_page; //PAGINA PRINCIPAL "INDEX.h"
String m = CerrarMODULO; //PAGINA DE CIERRE DE MODULO
String t = TestModulo;//PAGINA DE PREUBA DE TIMBRES
bool Tuf[17]={0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};  


//DECLARACION DE SERVIDOR IOT DE AMAZON
const char* mqtt_server = "aklvwl0ribi6h.iot.us-west-2.amazonaws.com";
const char* TopicPub = "0001PS052019V4";//DECLARACION DE PUBLICACION DE TOPICO DE MODULO
const char* TopicSub = "0001PS052019V4";//DECLARACION DE SUBSCRIPCION DE TOPICO DE MODULO
String Ptopico;//String
String Stopico;//String


///////////////DECLARACION DE FUNCIO DE CONEXION A MQTT/////////////////////
WiFiClientSecure wifiClient;
PubSubClient mqttClient(wifiClient);
ESP8266WebServer server(80); 

long lastMsg = 0;
char msg[50];
int value = 0;
boolean configuracion_OK=false, estado=false;
String ConfigOK;




//////////////////FUNCION PUBLICAR TOPICO//////////////////////
void publicarTopico(int dato)// funcion que se ejecuta cuando pasan 10 segundos para enviar topicos
{
byte lectura;
String strlectura;
int indice=0;
int posicion;
indice = (3*dato) + 47;
posicion=indice;

//FRAGMENTO QUE REALIZA EL CALCULO DE UBICACION EN MEORIA
for(indice;indice<posicion+3;indice++)
{
lectura = EEPROM.read(indice);
if(lectura!=255)
{
strlectura+=(char)lectura;  
}
}

char jsonStr[200];
//IMPRIME EN PANTALLA SI PUBLICO MENSAJE PARA DEBUGUEAR PROGRAMA
Serial.print("Mensaje publicado:\n");
Serial.println(strlectura);
strlectura.toCharArray(jsonStr,200);
mqttClient.publish(TopicPub,jsonStr);//publica topico a servidor mqtt
}


//////////////// FUNCION QUE SE EJECUTA CUANDO HAY UN TOPICO RECIBIDO , SIEMPRE Y CUANDO ESTE SUBSCRIPTO///////////////
void callback(char* topic, byte* payload, unsigned int length)
{
  Serial.print("Mensaje recibido [");
  Serial.print(topic);
  Serial.print("]\n");
  for (int i = 0; i < length; i++)
  Serial.print((char)payload[i]);
  Serial.println();
}


////////////// FUNCION DE RECONEXION DE SERVIDOR//////////////
void reconnect() {
  //LOOP DE RECONEXION
  while (!mqttClient.connected()) {
    Serial.print("Intentando conectarse con MQTT...");
    //CREA UN CLIENTE ALEATORIAMENTE 
    String clientId = "ESP8266Client-";
    clientId += String(random(0xffff), HEX);
    // INTENTA CONEXION
    if (mqttClient.connect(clientId.c_str())) {
      Serial.println("conectado");
      }
    else 
    {
      Serial.print("error, rc=");
      Serial.print(mqttClient.state());
      Serial.println(" intentando nuevamente en 5 segundos");
      // ESPERA 5 SEGUNDOS Y VULEVE AITENTAR CONECTARSE
      delay(5000);
    }
  }
}

/////////////////////////FUNCION DE CONEXION A SERVIOR MQTT CON CERTIFICADOS IOT/////////////////

void setup_wifiClient() {
  wifiClient.setCertificate(cert_der, cert_der_len);
  wifiClient.setPrivateKey(private_der, private_der_len);
}
//CONEXION A SERVIDOR MQTT IOT
void setup_mqttClient() {
  mqttClient.setServer(mqtt_server, 8883);
  mqttClient.setCallback(callback);  
}

////////////////////////CONFIGURACION DE HARDWARE////////////////////////////////////

void setup() {
  //DEFINICION DE PUERTO SERIE Y ASIGNACION DE PINES DE ENTRADA
  EEPROM.begin(512);
  Serial.begin(115200);
  Serial.println();
  pinMode(Pctrl, OUTPUT);
  pinMode(Clk, OUTPUT);
  pinMode(DataSerIn, INPUT);
  //SE INICIA WIFI PARA IDENTIFICAR LAS CONEXION DE WIFI DISPONIBLES, SI NO POSEE NINGUNA ALMACENADA PASA EL MODULO A MODO ACCES POINT.
  WiFiManager
  WiFiManager wifiManager;

  // SI LA CONFIGURACION FUE GUARDADA EXITOSAMENTE SALE DE MODO ACESS POINT
  wifiManager.setBreakAfterConfig(true);

          //DFINCION DE CLAVE Y NOMBRE DE USUARIO DE AP
          if (!wifiManager.autoConnect("PorteroSmart","12345678")) {// importante , para que pida password debe ser mayor a 8 caracteres
          Serial.println("error en conexion, reset para ver las opciones de conexion");
         delay(3000);
         ESP.reset();
     delay(5000);
    }
  Serial.println("conectado)");

//MUESTRA DIRECCION IP
  Serial.println("local ip");
  Serial.println(WiFi.localIP());
  

  setup_wifiClient();
  setup_mqttClient(); // CONFIGURACION DE CLIENTES MQTT
  Serial.println(WiFi.localIP());
  server.begin();

//GUARDA EN MEMORIA SI LA CONGIGURACION FUE EXITOSA
ConfigOK = EEPROM.read(0);

Serial.println(ConfigOK);  

//DEBUG PARA IDENTIFICAR SI SE GUARDO EXITOSAMENTE EN MEMORIA
  if(ConfigOK == "1")
    {
    Serial.println(" Equipo configurado");  
    if (!mqttClient.connected())// verifica si esta conectado al servior mqtt
    {
    reconnect();  // en caso que no este conectado llama a la funcion reconnect
    } 
    }
  if(ConfigOK == "0")
 {
   Serial.println(" Esperando configuracion, el equipo no esta configurado"); 
    
  }    

/////////////////////////CONFIGURACION PAGINA WEB DE///////////////////////////////////


  delay(10);
  
////SE EJECUTA CUANDO SE COLOCA EN NAVEGADOR EL IP
 server.on("/", []()
 {                                         //RUTA "/" DE SOLICITUD HTTP
 //String s = MAIN_page; //Read HTML contents
 server.send(200, "text/html", s); //Send web page
 });     

 
 ////SE EJECUT CUANDO click BOTON RESET DE FABRICA////
 server.on("/reset", []()
 {                                         //RUTA "/" DE SOLICITUD HTTP
 //String s = MAIN_page; //Read HTML contents
 for(int i=0;i<512;i++)
{
  //delay(100);
  //Serial.println("Borrando memoria");
  EEPROM.write(i,0);
  ConfigOK= "0";
}

// GUARDO EN MEMORIA QUE EL EQUIPO ESTA RESTEADO DE FABRICA
EEPROM.write(0,0);

mqttClient.disconnect();


//VUELVE  MOSTRAR EN EL NAVEGADOR LA PAGINA DE LOGIN///
server.send(200, "text/html", s); //MUESTRA PAGINAS WEB INDDEX.H
Serial.println(ConfigOK);
Serial.println(" Equipo reseteado de fabrica");

});     


//////////////////////PAGINA DE PRUEBA DE TIMPBRE EN NAVEGADOR//////////////////////////

server.on("/TestModulo", []()
 {                                         //RUTA "/" DE SOLICITUD HTTP
 //String s = MAIN_page; //Read HTML contents
 //server.send(200, "text/html", t); //Send web page
 //#F3EDED;
 String body = "<!DOCTYPE html> <html>\n";
  body +="<head><meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, user-scalable=no\">\n";
  body +="<meta http-equiv=\"refresh\" content=\"0.4\">\n";
  body +="<title> Portero Smart</title>\n";
  body +="<style> .por {background-color: orange; color:black; font-size:28px;text-align:center;width:400px;height:550px; border: 5px solid powderblue;";
  body +="margin: 20px; padding:20px;}\n";
  body +="body{background-color: white;}\n";
  body +="</style>\n";
  body +="</head>\n";
  body +="<a href=\"http://192.168.43.177\">Volver Pagina Login</a>";
  body +="<body>\n";
  body +="<h1 class=\"por\">PRUEBA DE TIMBRES \n";
  body += String(switchVar1);
  body +="<br>UF1:\n";
  body +=bool(Tuf[1]);
  body +="\n<br>";
  body +="UF2:\n";
  body +=bool(Tuf[2]);
  body +="\n<br>";
  body +="UF3:\n";
  body +=bool(Tuf[3]);
  body +="\n<br>";
  body +="UF4:\n";
  body +=bool(Tuf[4]);
  body +="\n<br>";
  body +="UF5:\n";
  body +=bool(Tuf[5]);
  body +="\n<br>";
  body +="UF6:\n";
  body +=bool(Tuf[6]);
  body +="\n<br>";
  body +="UF7:\n";
  body +=bool(Tuf[7]);
  body +="\n<br>";
  body +="UF8:\n";
  body +=bool(Tuf[8]);
  body +="\n<br>";
body +="UF9:\n";
  body +=bool(Tuf[9]);
  body +="\n<br>";
body +="UF10:\n";
  body +=bool(Tuf[10]);
  body +="\n<br>";
body +="UF11:\n";
  body +=bool(Tuf[11]);
  body +="\n<br>";
body +="UF12:\n";
  body +=bool(Tuf[12]);
  body +="\n<br>";
body +="UF13:\n";
  body +=bool(Tuf[13]);
  body +="\n<br>";
body +="UF14:\n";
  body +=bool(Tuf[14]);
  body +="\n<br>";
body +="UF15:\n";
  body +=bool(Tuf[15]);
  body +="\n<br>";
body +="UF16:\n";
  body +=bool(Tuf[16]);
  body +="\n<br>";
  body +="\n</p>";
  body +="</h1>\n";
 
  
  body +="</html>";
 
  server.send(200, "text/html", body); 


 }); 



//////////// SE EJECUTA CUANDO SE ENVIA FORULARIO DE PAGINAG HTML CORRIENDO EN NAVEGADOR/////////////////////////
server.on("/topicos", []()
{                                      //RUTA "/led" DE SOLICITUD HTTP
  String estadoHTML;
  
  //MUESTRA EN PUERTO SERIE LOS DATOS ENVIADOS DE FOMRULARIO
  
  //Serial.println(server.arg("detener"));

// GUARDA LOS DATOS DEL FOMRULARIO EN LAS VARIABLES
  
//estadoHTML=server.arg("detener");

//printf("%d",configuracion_OK);

//Serial.println(estadoHTML);
String UF="UF";
String UF_="";
String _UF="";
String T="Timbre";
String T_="";
String _T="";
byte lectura;
String strlectura;
String Cantidad;
int k=0;
Ptopico = server.arg("Ptopico");
Stopico = server.arg("Stopico");
Cantidad = server.arg("CantUnidades");
int value;
value = Cantidad.toInt();

for(k=0;k<value;k++)
{

UF_ = (String) k;
_UF = UF + UF_;

T_ = (String) k;
_T = T + T_;

Serial.print(_UF);
Serial.print(":  "); 
estadoHTML = server.arg(_UF);
//obtengo el numero de UF

int valor;
int h;
//convierto el caracter en entero
valor = estadoHTML.toInt();
//table de conversion para ubicar en memoria
valor = (3*valor) + 47;
h=valor;
Serial.println(estadoHTML); 


Serial.print(_T);
Serial.print(":  ");
estadoHTML = server.arg(_T);
//guardo en memoria timbre correpondiente a la UF

int tamano=estadoHTML.length();// CALCULO EL TAMAÃ‘O DE estado.HTML
char inchar[3];
estadoHTML.toCharArray(inchar,tamano+1);// paso el array a cada char para luego guardarlo en memeoria
//GUARDA EN MOMEORIA LOS DATOS RECIBIDOS POR METODO GET

for(int i=0;i<tamano;i++,valor++)
{
  EEPROM.write(valor,inchar[i]);
}


// si el dato que guardo en memeoria es menor a 3 byte , los restantes lo grabo con 255.
for(int i=tamano+h;i<3+h;i++)
{
 EEPROM.write(i,255);

}
//GUARDO EN POSICION 0 DE MEMORIA INDICANDO QUE YA ESTA CONFIGURADO EL EQUIPO(valor 1)
EEPROM.write(0,1);

EEPROM.commit();
//impirmo en puero serie los datos que se guardaron en memoria
Serial.println(estadoHTML);

_T="";
_UF="";
}

//visualiza lo que se grabo en memoria

for(int j=50;j<512;j++)
{
lectura = EEPROM.read(j);
strlectura+=(char)lectura;  

}

Serial.println(strlectura);

//MUESTRA EN PUERTO SERIE LOS DATOS GUARDADOS, PARA DEBUG

for(int j=0;j<50;j++)
{
lectura = EEPROM.read(j);

strlectura+=(char)lectura;  
//}
}
Serial.println(strlectura);

//LLAMA A FUNCION CONEXION CON SERVIDOR MQTT
if (!mqttClient.connected())// verifica si esta conectado al servior mqtt
{
  reconnect();  // en caso que no este coenctado llama a la funcion reconnect
}
//MUESTRA EN NAVEGADOR NUEVAMENTE PAGINA DE INICIO
server.send(200, "text/html", m);


});   
  
}

void loop() {
// LEE ENTRADA DE DESPLAZADOR SERIE

  digitalWrite(Pctrl, 1);      // cargo datos paralelos colocando el Pin en 1
  delayMicroseconds(20);        // espero para guardar
  digitalWrite(Pctrl, 0);      //pongo en 0 para finalizar la carga
  switchVar1 = shiftIn(DataSerIn, Clk);
  //LLAMA A FUNCION MQTT
  mqttClient.loop();
  long now = millis();
  //HABILITA FUNCION CLIENTE PARA VISUALIZAR PAGINA WEB EN NAVEGADOR
  server.handleClient();   
  
  
  }
  
 //DETECCION  DE TIMBRE 
 if (switchVar1 == 32767)//32767 /1
      {Tuf[1]=true;     
        if(ConfigOK == "1")
        {publicarTopico(1);}
       //ESPERA HASTA  QUE SUELTE EL PULSADOR
        while(switchVar1 == 32767)
          {switchVar1 = shiftIn(DataSerIn, Clk);
          delay(500);}
      }else
        {Tuf[1]=false;}
      
    if (switchVar1 == 63487)//63487 29183/2
      {Tuf[2]=true;
       if(ConfigOK == "1")
        {publicarTopico(2);
        }
         while(switchVar1 == 63487)
        {switchVar1 = shiftIn(DataSerIn, Clk);
        delay(500);  
         } 
      }else{Tuf[2]=false;}
     if (switchVar1 == 64511)// 64511 / 4
      { Tuf[3]=true;
        if(ConfigOK == "1")
        {publicarTopico(3);
        } 
      while(switchVar1 == 64511)
      {switchVar1 = shiftIn(DataSerIn, Clk);
      delay(500);  
      }
      }else{Tuf[3]=false;}

      if (switchVar1 == 65023) //65023 / 8
      {Tuf[4]=true;
       if(ConfigOK == "1")
        {publicarTopico(4);
        }while(switchVar1 == 65023)
        {switchVar1 = shiftIn(DataSerIn, Clk);
        delay(500);  
         }         
      }else{Tuf[4]=false;}
      if (switchVar1 == 65407)//65407 / 16
      {
        Tuf[5]=true;
        if(ConfigOK == "1")
        {
        publicarTopico(5);
        }
        while(switchVar1 == 65407)
        {switchVar1 = shiftIn(DataSerIn, Clk);
        delay(500);  
         }
      }else{Tuf[5]=false;}
     if (switchVar1 == 65527) // 65527 / 32
      {Tuf[6]=true;
       if(ConfigOK == "1")
        {publicarTopico(6);
        }
      while(switchVar1 == 65527)
        {switchVar1 = shiftIn(DataSerIn, Clk);
        delay(500);  
         }
      }else{Tuf[6]=false;}
     if (switchVar1 == 65533)// 65533 / 64  
      {Tuf[7]=true;
       if(ConfigOK == "1")
        {publicarTopico(7);
        }
        while(switchVar1 == 65533)
        {switchVar1 = shiftIn(DataSerIn, Clk);
        delay(500);  
         }     
      }else{Tuf[7]=false;}
    if (switchVar1 == 65531)//65531 / 128
      {Tuf[8]=true;
      if(ConfigOK == "1")
        {publicarTopico(8);
        }
        while(switchVar1 == 65531)
        {switchVar1 = shiftIn(DataSerIn, Clk);
        delay(500);  
         }
      }else{Tuf[8]=false;}
    if (switchVar1 == 256)
      {Tuf[9]=true;
       if(ConfigOK == "1")
        {publicarTopico(9);
        }
        while(switchVar1 == 256)
        {switchVar1 = shiftIn(DataSerIn, Clk);
        delay(500);  
         }
      }else{Tuf[9]=false;}
 
     if (switchVar1 == 57343)//57343 / 512  
      {Tuf[10]=true;
         if(ConfigOK == "1")
        {publicarTopico(10);
        }
        while(switchVar1 == 57343)
        {switchVar1 = shiftIn(DataSerIn, Clk);
        delay(500);  
         }
      }else{Tuf[10]=false;}
      if (switchVar1 == 1024) 
      {Tuf[11]=true;     
       if(ConfigOK == "1")
        {publicarTopico(11);
        }
        while(switchVar1 == 1024)
        {switchVar1 = shiftIn(DataSerIn, Clk);
        delay(500);  
         }
      }else{Tuf[1]=false;}

   if (switchVar1 == 2048)// / 2048
      {Tuf[12]=true;
       if(ConfigOK == "1")
        {publicarTopico(12);
        }
        while(switchVar1 == 2048)
        {switchVar1 = shiftIn(DataSerIn, Clk);
        delay(500);  
         }
       }else{Tuf[12]=false;}

    if (switchVar1 == 65471)//65471 / 4096
      {
      Tuf[13]=true;
          if(ConfigOK == "1")
        {publicarTopico(13);
        }
        while(switchVar1 == 65471)
        {switchVar1 = shiftIn(DataSerIn, Clk);
        delay(500);  
         }
      }else{Tuf[13]=false;}

    if (switchVar1 == 65503)//65503 / 8192
      {Tuf[14]=true;
      if(ConfigOK == "1")
        {publicarTopico(14);
        }
        while(switchVar1 == 65503)
        {switchVar1 = shiftIn(DataSerIn, Clk);
        delay(500);  
         }
      }else{Tuf[14]=false;}

   if (switchVar1 == 65534) // 65534/ 16384
      {Tuf[15]=true; 
      if(ConfigOK == "1")
        {publicarTopico(15);
        }
        while(switchVar1 == 65534)
        {switchVar1 = shiftIn(DataSerIn, Clk);
        delay(500);  
         }
      }else{Tuf[15]=false;}

      if (switchVar1 == 65519) // 65519 / 32768
      {Tuf[16]=true;
        if(ConfigOK == "1")
        {publicarTopico(16);
        }
        while(switchVar1 == 65519)
        {switchVar1 = shiftIn(DataSerIn, Clk);
        delay(500);  
         }
      }else{Tuf[16]=false;}


///////// CODIGO DE PRUEBA CUANDO SE UTILIZABA PUERTO SERIE COMO DISPARADOR DE TOPICOS///////////////////////
/*
if (Serial.available())
  { 
    int value1=0;
    char inByte = Serial.read();
    //int  dto= Serial.read();
    //if (dto = 65533)
    //{
    //Serial.println(switchVar1, BIN);  
   // }
    //value1 = inByte.toInt();
    //Serial.println(inByte);
/*
if (incomingChar >= '0' && incomingChar <= '9')
data = (data * 10) + (incomingChar - '0');
*/

/*    if(inByte >= '0' && inByte <= '9')
    {
    value1=(value1 * 10)+(inByte - '0'); 
    }
  //if(value1 == 2)
    //{
    //Serial.println(value1);  
     
    publicarTopico(value1);
    
   // }    
  }*/

}


//////////////////////////////////// FUNCION PARA ARMAR JSON/////////////////////////
String buildJson(String strlectura) {
  String data = "{";
  data+="\n";
  data+="\"timbre\":\"Psmart\",";
  data+="\n";
  data+="\"UF\":";
  data+=(String)strlectura;
  data+="\n";
  data+="}";
  return data;
}




/////////////FUNCION DE LECTURA DE PULSADORES///////////////////////
word shiftIn(int DataPin, int ClockPin) {
  int i;
  int temp = 0;
  int pinState;
  word DataIn = 0;
  for (i = 15; i >= 0; i--)
  {
    digitalWrite(ClockPin, 0);
    delayMicroseconds(0.2);
    temp = digitalRead(DataPin);
    if (temp) {
      pinState = 1;
      //set the bit to 0 no matter what
      DataIn = DataIn | (1 << i);
    }
    else {
   pinState = 0;
    }
 digitalWrite(ClockPin, 1);

  }

  return DataIn;
}
